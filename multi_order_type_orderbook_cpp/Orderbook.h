#pragma once

#include <map>
#include <unordered_map>
#include <thread>
#include <condition_variable>
#include <mutex>

#include "Usings.h"
#include "Order.h"
#include "OrderModify.h"
#include "OrderbookLevelInfos.h"
#include "Trade.h"

/**
 * @brief Central limit order book managing bids/asks, order matching, and order lifecycle.
 */
class Orderbook
{
private:

    /**
     * @brief Associates an order with its iterator in the price-level list for quick removal.
     */
    struct OrderEntry
    {
        OrderPointer order_{ nullptr };
        OrderPointers::iterator location_;
    };

    /**
     * @brief Aggregated quantity and order count at a price level (used for Fill‑Or‑Kill checks).
     */
    struct LevelData
    {
        Quantity quantity_{ }; // Total remaining quantity at this price
        Quantity count_{ };    // Number of orders at this price

        enum class Action
        {
            Add,
            Remove,
            Match,
        };
    };

    std::unordered_map<Price, LevelData> data_;
    std::map<Price, OrderPointers, std::greater<Price>> bids_;
    std::map<Price, OrderPointers, std::less<Price>> asks_;
    std::unordered_map<OrderId, OrderEntry> orders_;
    mutable std::mutex ordersMutex_;
    std::thread ordersPruneThread_;
    std::condition_variable shutdownConditionVariable_;
    std::atomic<bool> shutdown_{ false };

    /**
     * @brief Background task that cancels all Good‑For‑Day orders at 16:00.
     */
    void PruneGoodForDayOrders();

    /**
     * @brief Cancels a collection of orders (thread-safe wrapper).
     */
    void CancelOrders(OrderIds orderIds);

    /**
     * @brief Internal order cancellation (assumes ordersMutex_ is held).
     */
    void CancelOrderInternal(OrderId orderId);

    // Callbacks to update level data on order events
    void OnOrderCancelled(OrderPointer order);
    void OnOrderAdded(OrderPointer order);
    void OnOrderMatched(Price price, Quantity quantity, bool isFullyFilled);

    /**
     * @brief Updates aggregated quantity and order count at a price level.
     */
    void UpdateLevelData(Price price, Quantity quantity, LevelData::Action action);

    /**
     * @brief Checks whether a Fill‑Or‑Kill order can be fully filled.
     */
    bool CanFullyFill(Side side, Price price, Quantity quantity) const;

    /**
     * @brief Checks whether any match is possible at the given price.
     */
    bool CanMatch(Side side, Price price) const;

    /**
     * @brief Matches orders at the current best bid/ask until no further matches.
     */
    Trades MatchOrders();

public:

    /**
     * @brief Constructor – starts the background pruning thread.
     */
    Orderbook();

    // Disable copying and moving (book is a unique resource)
    Orderbook(const Orderbook&) = delete;
    void operator=(const Orderbook&) = delete;
    Orderbook(Orderbook&&) = delete;
    void operator=(Orderbook&&) = delete;

    /**
     * @brief Destructor – signals shutdown and joins pruning thread.
     */
    ~Orderbook();

    /**
     * @brief Adds an order to the book, performs market‑order conversion, and triggers matching.
     * @return Trades generated by this addition.
     */
    Trades AddOrder(OrderPointer order);

    /**
     * @brief Cancels an order by ID.
     */
    void CancelOrder(OrderId orderId);

    /**
     * @brief Modifies an existing order (cancel + add new).
     * @return Trades resulting from the modified order.
     */
    Trades ModifyOrder(OrderModify order);

    /**
     * @brief Returns the total number of orders currently in the book.
     */
    std::size_t Size() const;

    /**
     * @brief Returns a snapshot of the current order book (price levels with aggregated quantities).
     */
    OrderbookLevelInfos GetOrderInfos() const;
};
